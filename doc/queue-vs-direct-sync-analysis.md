# 增量同步：使用队列 vs 不使用队列的差异分析

## 一、核心差异

### 1.1 使用队列（当前实现）

**架构流程**：
```
binlog事件 → Listener → BufferActuatorRouter.offer() → 队列缓存
                                                          ↓
定时器（300ms）→ AbstractBufferActuator.pull() → 批量打包 → batchUpdate() → 目标数据库
```

**关键特性**：
- **批量处理**：将多个零散事件打包成批次（`BufferPullCount` 配置）
- **异步写入**：监听线程不阻塞，事件快速入队
- **定时拉取**：每 300ms 从队列拉取一批数据
- **分区合并**：相同表的事件合并到同一个批次

### 1.2 不使用队列（直接同步）

**架构流程**：
```
binlog事件 → Listener → 直接调用 writer() → 目标数据库
```

**关键特性**：
- **单条写入**：每个事件单独执行一次数据库写入
- **同步阻塞**：监听线程必须等待写入完成
- **无批量优化**：无法利用数据库批量写入能力

## 二、性能差异

### 2.1 写入性能对比

**使用队列（批量写入）**：
```java
// AbstractDatabaseConnector.executeWriter()
databaseTemplate.batchUpdate(executeSql, batchRows(fields, data));
// 一次 SQL 执行，写入 N 条记录（N = BufferPullCount，默认 1000）
```

**不使用队列（单条写入）**：
```java
// 每个事件单独执行
for (ChangedEvent event : events) {
    databaseTemplate.update(executeSql, params);  // 每次都是单独的数据库往返
}
// N 次 SQL 执行，每次写入 1 条记录
```

**性能差异**：
- **网络往返次数**：批量写入 = 1 次，单条写入 = N 次（N 倍差异）
- **数据库连接开销**：批量写入 = 1 次连接，单条写入 = N 次连接
- **SQL 解析优化**：批量写入可以复用 SQL 计划，单条写入每次都要解析
- **事务开销**：批量写入 = 1 个事务，单条写入 = N 个事务（如果开启自动提交）

**实际性能提升**：
- 假设 `BufferPullCount = 1000`，批量写入性能提升 **10-100 倍**（取决于数据库类型和网络延迟）

### 2.2 吞吐量对比

**场景**：源数据库每秒产生 1000 条变更事件

**使用队列**：
- 事件快速入队（微秒级）
- 每 300ms 批量处理一次
- 每次批量写入 1000 条（或更少）
- **吞吐量**：轻松处理 1000+ 事件/秒

**不使用队列**：
- 每个事件必须等待写入完成（毫秒级）
- 假设单次写入耗时 5ms
- **吞吐量**：最多 200 事件/秒（1000ms / 5ms）
- **瓶颈**：监听线程被阻塞，无法及时处理新事件

## 三、功能差异

### 3.1 背压控制

**使用队列**：
```java
// BufferActuatorRouter.offer()
if (queue.size() >= capacity) {
    // 队列满时阻塞，防止内存溢出
    queue.put(request);  // BlockingQueue.put() 会阻塞
}
```
- **优势**：队列满时自动阻塞，防止内存溢出
- **保护机制**：监听线程被阻塞，源数据库 binlog 读取暂停

**不使用队列**：
- **无背压控制**：如果写入慢，事件会堆积在内存中
- **风险**：内存溢出，系统崩溃

### 3.2 异步处理

**使用队列**：
- **监听线程**：只负责接收事件并快速入队（微秒级）
- **写入线程**：独立的定时器线程负责批量写入
- **解耦**：监听和写入完全解耦，互不影响

**不使用队列**：
- **监听线程阻塞**：必须等待每次写入完成
- **影响**：如果目标数据库慢，binlog 监听会延迟，可能导致 binlog 位置落后

### 3.3 分区合并

**使用队列**：
```java
// AbstractBufferActuator.submit()
String key = getPartitionKey(poll);  // 按表分组
Response response = map.compute(key, (k, v) -> {
    if (v == null) {
        return responseClazz.newInstance();
    }
    return v;
});
partition(poll, response);  // 相同表的事件合并
```
- **优势**：相同表的事件合并到同一个批次，减少数据库连接切换

**不使用队列**：
- **无合并**：每个事件单独处理，无法合并

## 四、资源消耗差异

### 4.1 数据库连接

**使用队列**：
- **连接数**：每个 BufferActuator 实例使用少量连接（通常 1-10 个）
- **连接复用**：批量写入时连接复用率高

**不使用队列**：
- **连接数**：每个事件都需要连接（或连接池）
- **连接开销**：频繁创建/销毁连接，资源浪费

### 4.2 内存使用

**使用队列**：
- **内存缓冲**：队列中缓存待处理事件（可控，有容量限制）
- **内存可控**：通过 `BufferQueueCapacity` 配置控制

**不使用队列**：
- **无缓冲**：事件直接处理，但写入慢时可能堆积
- **内存不可控**：如果写入慢，事件会堆积在调用栈中

## 五、适用场景

### 5.1 使用队列（推荐）

**适用场景**：
- ✅ **高吞吐量**：源数据库变更频繁（> 100 事件/秒）
- ✅ **批量优化**：目标数据库支持批量写入（MySQL、SQL Server、PostgreSQL 等）
- ✅ **实时性要求不高**：可以接受 300ms 延迟（定时器间隔）
- ✅ **资源受限**：需要控制数据库连接数和内存使用

**优势总结**：
- 🚀 **性能提升**：批量写入性能提升 10-100 倍
- 🛡️ **背压控制**：防止内存溢出
- 🔄 **异步处理**：监听和写入解耦
- 📦 **资源优化**：减少数据库连接和网络往返

### 5.2 不使用队列（不推荐）

**适用场景**：
- ❌ **极低延迟要求**：需要毫秒级延迟（但通常不必要）
- ❌ **单条事件处理**：每个事件需要单独处理逻辑（但可以通过插件实现）
- ❌ **目标不支持批量**：目标数据库不支持批量写入（罕见）

**劣势总结**：
- 🐌 **性能差**：单条写入性能低
- ⚠️ **阻塞风险**：监听线程可能被阻塞
- 💥 **内存风险**：无背压控制，可能内存溢出
- 📈 **资源浪费**：频繁的数据库连接和网络往返

## 六、实际案例

### 6.1 高吞吐量场景

**场景**：MySQL binlog 每秒产生 5000 条 INSERT 事件

**使用队列**：
- 事件快速入队（< 1ms）
- 每 300ms 批量写入 1000 条
- **性能**：轻松处理 5000+ 事件/秒
- **延迟**：平均 150ms（300ms / 2）

**不使用队列**：
- 每个事件写入耗时 5ms
- **性能**：最多 200 事件/秒（严重瓶颈）
- **延迟**：事件堆积，延迟不断增长
- **结果**：系统无法跟上源数据库变更速度

### 6.2 低吞吐量场景

**场景**：MySQL binlog 每秒产生 10 条 UPDATE 事件

**使用队列**：
- 事件快速入队
- 每 300ms 批量写入（可能只有 3-10 条）
- **性能**：轻松处理
- **延迟**：平均 150ms

**不使用队列**：
- 每个事件写入耗时 5ms
- **性能**：可以处理（但仍有 5ms 延迟）
- **延迟**：5ms（比队列方式更快）

**结论**：即使低吞吐量场景，队列方式的 150ms 延迟通常也是可接受的，而且提供了更好的扩展性。

## 七、总结

### 7.1 核心差异

| 维度 | 使用队列 | 不使用队列 |
|------|---------|-----------|
| **写入方式** | 批量写入（batchUpdate） | 单条写入（update） |
| **性能** | 10-100 倍提升 | 基准性能 |
| **吞吐量** | 高（1000+ 事件/秒） | 低（< 200 事件/秒） |
| **延迟** | 平均 150ms（可配置） | 5-50ms（取决于数据库） |
| **背压控制** | ✅ 有（队列满时阻塞） | ❌ 无（可能内存溢出） |
| **异步处理** | ✅ 是（监听和写入解耦） | ❌ 否（监听线程阻塞） |
| **资源消耗** | 低（连接复用） | 高（频繁连接） |
| **适用场景** | 高吞吐量、批量优化 | 极低延迟（罕见） |

### 7.2 设计理念

**使用队列的设计理念**：
1. **批量优化**：利用数据库批量写入能力，大幅提升性能
2. **异步解耦**：监听和写入分离，互不影响
3. **背压控制**：队列满时阻塞，防止系统过载
4. **资源优化**：减少数据库连接和网络往返

**不使用队列的问题**：
1. **性能瓶颈**：单条写入无法利用批量优化
2. **阻塞风险**：监听线程被写入操作阻塞
3. **无保护机制**：写入慢时可能导致内存溢出
4. **资源浪费**：频繁的数据库连接和网络往返

### 7.3 结论

**增量同步使用队列是必要的**，原因：
1. ✅ **性能提升显著**：批量写入性能提升 10-100 倍
2. ✅ **系统稳定性**：背压控制防止内存溢出
3. ✅ **资源优化**：减少数据库连接和网络往返
4. ✅ **扩展性好**：可以轻松处理高吞吐量场景

**不使用队列的代价**：
1. ❌ **性能严重下降**：无法处理高吞吐量场景
2. ❌ **系统不稳定**：无背压控制，可能内存溢出
3. ❌ **资源浪费**：频繁的数据库连接和网络往返

**建议**：除非有极特殊的低延迟要求（< 10ms），否则应该使用队列机制。
