# 改造方案：存储源端数据用于重试

## 一、现状分析

### 当前实现
1. **存储阶段**：存储的是 `targetDataList`（目标数据）
   - 字段名：目标表字段名
   - 数据：已通过字段映射、参数转换、插件转换处理
   - 位置：`GeneralBufferActuator.distributeTableGroup()` 第302行

2. **重试阶段**：
   - 反序列化：使用目标表字段类型
   - 转换：通过 `pickSourceData()` 将目标数据转换回源数据
   - 问题：类型转换复杂，容易出现类型不匹配错误

### 存在的问题
1. **类型转换复杂**：需要从目标数据反向转换回源数据，涉及类型转换
2. **类型不匹配**：源表字段类型与目标表字段类型不一致时，容易出现转换错误
3. **逻辑不直观**：重试应该是"重新执行一次同步流程"，而不是"反向转换后再执行"
4. **规则变化**：如果字段映射或转换规则发生变化，重试时使用的是旧规则转换的数据

## 二、改造方案

### 方案概述
**存储源端数据（sourceDataList）而不是目标数据（targetDataList）**

### 优点
1. ✅ **逻辑简单**：重试时直接使用源数据，重新执行完整的同步流程
2. ✅ **避免类型转换**：不需要反向转换，避免类型不匹配问题
3. ✅ **符合语义**：重试就是"重新执行一次同步"，使用源数据更合理
4. ✅ **规则更新**：字段映射或转换规则变化时，重试使用最新规则
5. ✅ **数据完整性**：源数据是原始数据，包含完整信息

### 缺点
1. ⚠️ **需要改造**：需要修改存储和反序列化逻辑
2. ⚠️ **兼容性**：需要处理历史数据的兼容性（可选）

## 三、具体改造步骤

### 步骤1：修改存储逻辑
**文件**：`dbsyncer-parser/src/main/java/org/dbsyncer/parser/flush/impl/GeneralBufferActuator.java`

**修改位置**：第302行

**修改前**：
```java
}catch (Exception e){
    logger.error("process batch data error:",e);
    result = new Result();
    result.error = e.getMessage();
    result.setTableGroupId(tableGroup.getId());
    result.setTargetTableGroupName(context.getTargetTableName());
    result.addFailData(targetDataList);  // 存储目标数据
}
```

**修改后**：
```java
}catch (Exception e){
    logger.error("process batch data error:",e);
    result = new Result();
    result.error = e.getMessage();
    result.setTableGroupId(tableGroup.getId());
    result.setTargetTableGroupName(context.getTargetTableName());
    result.addFailData(sourceDataList);  // 存储源数据
}
```

**说明**：`sourceDataList` 在第247行已经通过 `pickTargetData()` 方法填充，包含源表字段名和源表数据。

### 步骤2：修改反序列化逻辑
**文件**：`dbsyncer-biz/src/main/java/org/dbsyncer/biz/impl/DataSyncServiceImpl.java`

**修改位置**：`getBinlogData()` 方法（第124-147行）

**修改前**：
```java
// 4、反序列化
// 注意：存储的是目标数据（targetDataList），字段名是目标表字段名
// 所以需要使用目标表字段类型来反序列化，然后通过 pickSourceData 转换为源数据
final Picker picker = new Picker(tableGroup);
final Map<String, Field> targetFieldMap = picker.getTargetFieldMap();
message.getRowMap().forEach((k, v) -> {
    if (targetFieldMap.containsKey(k)) {
        Object val = BinlogMessageUtil.deserializeValue(targetFieldMap.get(k).getType(), v);
        // ...
    }
});
```

**修改后**：
```java
// 4、反序列化
// 注意：存储的是源数据（sourceDataList），字段名是源表字段名
// 所以需要使用源表字段类型来反序列化，直接使用源数据
final Map<String, Field> sourceFieldMap = tableGroup.getSourceTable().getColumn().stream()
        .filter(java.util.Objects::nonNull)
        .collect(Collectors.toMap(Field::getName, f -> f, (k1, k2) -> k1));
message.getRowMap().forEach((k, v) -> {
    if (sourceFieldMap.containsKey(k)) {
        Object val = BinlogMessageUtil.deserializeValue(sourceFieldMap.get(k).getType(), v);
        // 处理二进制对象显示
        if (prettyBytes) {
            if (val instanceof byte[]) {
                byte[] b = (byte[]) val;
                if (b.length > 128) {
                    target.put(k, String.format("byte[%d]", b.length));
                    return;
                }
                target.put(k, Arrays.toString(b));
                return;
            }
        }
        target.put(k, val);
    }
});
```

### 步骤3：简化重试逻辑
**文件**：`dbsyncer-biz/src/main/java/org/dbsyncer/biz/impl/DataSyncServiceImpl.java`

**修改位置**：`sync()` 方法（第231-252行）

**修改前**：
```java
// 从binlogData的key中提取列名
List<String> columnNames = new ArrayList<>();
if (!CollectionUtils.isEmpty(binlogData)) {
    columnNames.addAll(binlogData.keySet());
}

// 转换为源字段
final Picker picker = new Picker(tableGroup);
List<Object> changedRow = picker.pickSourceData(binlogData);

// 创建RowChangedEvent时传入columnNames，确保重试时能正确处理
RowChangedEvent changedEvent = new RowChangedEvent(sourceTableName, event, changedRow, null, null, columnNames);
```

**修改后**：
```java
// 从binlogData的key中提取列名（源表字段名）
List<String> columnNames = new ArrayList<>();
if (!CollectionUtils.isEmpty(binlogData)) {
    columnNames.addAll(binlogData.keySet());
}

// 直接使用源数据，转换为List<Object>格式
final Picker picker = new Picker(tableGroup);
List<Field> sourceFields = picker.getSourceFields();
List<Object> changedRow = new ArrayList<>();
for (Field field : sourceFields) {
    changedRow.add(binlogData.get(field.getName()));
}

// 创建RowChangedEvent时传入columnNames，确保重试时能正确处理
RowChangedEvent changedEvent = new RowChangedEvent(sourceTableName, event, changedRow, null, null, columnNames);
```

### 步骤4：移除不再需要的 pickSourceData 方法
**文件**：`dbsyncer-parser/src/main/java/org/dbsyncer/parser/model/Picker.java`

**说明**：由于改为存储源数据，`pickSourceData` 方法不再需要，已删除。

## 四、兼容性处理

**采用方案A：不兼容处理**
- 优点：代码简单，逻辑清晰
- 缺点：历史数据无法重试（历史失败数据需要清理或迁移）

**说明**：新版本将只支持新格式（源数据），历史数据如需重试，需要先清理旧数据。

## 五、测试建议

1. **单元测试**：
   - 测试存储源数据
   - 测试反序列化源数据
   - 测试重试流程

2. **集成测试**：
   - 测试完整同步流程失败后的重试
   - 测试类型转换场景（TIMESTAMP -> DECIMAL）
   - 测试字段映射变化后的重试

## 六、风险评估

| 风险项 | 风险等级 | 应对措施 |
|--------|---------|---------|
| 历史数据无法重试 | 中 | 发布前清理历史失败数据，或提供数据迁移工具 |
| 存储空间增加 | 低 | 源数据和目标数据大小相近 |
| 代码改动影响 | 中 | 充分测试，逐步发布 |

## 七、总结

**采用存储源端数据的方案**，原因：
1. 逻辑更简单，符合重试语义
2. 避免类型转换问题
3. 支持规则更新
4. 代码更易维护

**实施策略**：采用不兼容方案，代码更简洁，历史数据需要清理。

