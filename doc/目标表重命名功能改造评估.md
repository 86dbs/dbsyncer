# 目标表重命名功能改造评估

## 一、需求概述

在添加数据表映射后，可对目标表进行重命名。

## 二、现状分析

### 2.1 当前实现

1. **数据模型**
   - `TableGroup` 类中包含 `sourceTable` 和 `targetTable` 两个 `Table` 对象
   - 目标表名称存储在 `TableGroup.targetTable.name` 中

2. **添加表映射流程**
   - 前端：`editTable.html` 中通过下拉选择目标表
   - 后端：`TableGroupService.add()` → `TableGroupChecker.checkAddConfigModel()` 
   - 参数：通过 `targetTable` 参数传入目标表名称

3. **编辑表映射流程**
   - 前端：`editTableGroup.html` 中显示目标表名称（只读）
   - 后端：`TableGroupService.edit()` → `TableGroupChecker.checkEditConfigModel()`
   - **当前限制**：编辑时只能修改字段映射关系，不能修改目标表名称

### 2.2 关键代码位置

#### 后端代码
- `TableGroup.java` - 数据模型
- `TableGroupService.java` - 服务接口
- `TableGroupServiceImpl.java` - 服务实现
- `TableGroupChecker.java` - 校验器（第97-121行 `checkEditConfigModel` 方法）
- `TableGroupController.java` - 控制器

#### 前端代码
- `editTableGroup.html` - 编辑表映射页面（第53行显示目标表名称）
- `editTableGroup.js` - 编辑表映射JS逻辑

## 三、改造方案

### 3.1 功能设计

#### 3.1.1 前端改造

**位置**：`editTableGroup.html`

**改造内容**：
1. 将目标表名称从只读显示改为可编辑输入框
2. 添加目标表名称基本验证（仅非空校验）

**前端校验规则**（简化版）：
- **非空校验**：目标表名称不能为空（去除首尾空格后）
- **其他校验**：格式、长度等复杂校验交由目标数据库服务端处理
  - 不同数据库的表名规范不同（MySQL、SQL Server、PostgreSQL等各有差异）
  - 数据库服务端会在实际使用时进行校验，并返回明确的错误信息
  - 前端无需承担多数据库的校验工作，减少维护成本

**具体实现**：
```html
<!-- 原代码（第53行） -->
<p>目标源表：[[${tableGroup?.targetTable?.name}]]</p>

<!-- 改造后 -->
<div class="form-group">
    <label class="col-sm-3 control-label text-right">目标源表 <span class="text-danger">*</span></label>
    <div class="col-sm-9">
        <input id="targetTableName" 
               name="targetTable" 
               class="form-control" 
               type="text" 
               th:value="${tableGroup?.targetTable?.name}"
               placeholder="请输入目标表名称"
               required/>
    </div>
</div>
```

**JavaScript校验**（可选，简单实现）：
```javascript
// 在提交前进行非空校验（如果HTML5的required属性不够用）
function validateTargetTableName() {
    const $targetTableName = $("#targetTableName");
    const value = $targetTableName.val() ? $targetTableName.val().trim() : '';
    
    if (!value || value.length === 0) {
        bootGrowl("目标表名称不能为空", "danger");
        $targetTableName.focus();
        return false;
    }
    
    // 自动去除首尾空格
    $targetTableName.val(value);
    return true;
}

// 在提交函数中调用（可选）
function doTableGroupSubmit() {
    if (!validateTargetTableName()) {
        return;
    }
    // ... 其他提交逻辑 ...
}
```

#### 3.1.2 后端改造

**位置1**：`TableGroupChecker.checkEditConfigModel()` 方法

**改造内容**：
1. 支持接收 `targetTable` 参数
2. 如果提供了新的目标表名称，更新 `TableGroup.targetTable`
3. 检查是否与其他表映射冲突（源表+新目标表的组合）

**注意**：目标表是否存在会在保存 mapping 时自动检测（`MappingServiceImpl.edit()` 中的 `checkAllTargetTablesExist()` 方法），此处无需重复检查。

**具体实现**：
```java
@Override
public ConfigModel checkEditConfigModel(Map<String, String> params) throws Exception {
    logger.info("params:{}", params);
    Assert.notEmpty(params, "TableGroupChecker check params is null.");
    String id = params.get(ConfigConstant.CONFIG_MODEL_ID);
    TableGroup tableGroup = profileComponent.getTableGroup(id);
    Assert.notNull(tableGroup, "Can not find tableGroup.");
    Mapping mapping = profileComponent.getMapping(tableGroup.getMappingId());
    Assert.notNull(mapping, "mapping can not be null.");
    String fieldMappingJson = params.get("fieldMapping");
    Assert.hasText(fieldMappingJson, "TableGroupChecker check params fieldMapping is empty");

    // 新增：支持修改目标表名称
    String newTargetTableName = params.get("targetTable");
    if (StringUtil.isNotBlank(newTargetTableName)) {
        String sourceTableName = tableGroup.getSourceTable().getName();
        String oldTargetTableName = tableGroup.getTargetTable().getName();
        
        // 如果目标表名称发生变化，需要重新获取目标表信息
        if (!StringUtil.equals(newTargetTableName, oldTargetTableName)) {
            // 检查是否与其他表映射冲突
            checkRepeatedTable(mapping.getId(), sourceTableName, newTargetTableName, id);
            
            // 获取新目标表的主键信息（保持原有主键配置）
            String targetTablePK = StringUtil.join(
                tableGroup.getTargetTable().getColumn().stream()
                    .filter(Field::isPk)
                    .map(Field::getName)
                    .collect(Collectors.toList()), 
                ","
            );
            
            // 重新获取目标表信息
            Table newTargetTable = getTable(mapping.getTargetConnectorId(), newTargetTableName, targetTablePK);
            tableGroup.setTargetTable(newTargetTable);
        }
    }

    // 修改基本配置
    this.modifyConfigModel(tableGroup, params);

    // 修改高级配置：过滤条件/转换配置/插件配置
    this.modifySuperConfigModel(tableGroup, params);

    // 字段映射关系
    setFieldMapping(tableGroup, fieldMappingJson);

    // 重新初始化 sql 语言和相关缓存
    tableGroup.initCommand(mapping, connectorFactory);

    return tableGroup;
}
```

**位置2**：`TableGroupChecker.checkRepeatedTable()` 方法

**改造内容**：
1. 修改方法签名，支持排除当前编辑的表映射
2. 在检查重复时，排除自身

**具体实现**：
```java
/**
 * 检查是否存在重复映射关系
 * @param mappingId 映射ID
 * @param sourceTable 源表名称
 * @param targetTable 目标表名称
 * @param excludeTableGroupId 排除的表映射ID（编辑时使用，新增时传null）
 */
private void checkRepeatedTable(String mappingId, String sourceTable, String targetTable, String excludeTableGroupId) throws Exception {
    List<TableGroup> list = profileComponent.getTableGroupAll(mappingId);
    if (!CollectionUtils.isEmpty(list)) {
        for (TableGroup g : list) {
            // 排除自身（编辑时）
            if (StringUtil.isNotBlank(excludeTableGroupId) && StringUtil.equals(excludeTableGroupId, g.getId())) {
                continue;
            }
            // 数据源表和目标表都存在
            if (StringUtil.equals(sourceTable, g.getSourceTable().getName()) && 
                StringUtil.equals(targetTable, g.getTargetTable().getName())) {
                final String error = String.format("映射关系已存在.%s > %s", sourceTable, targetTable);
                logger.error(error);
                throw new RepeatedTableGroupException(error);
            }
        }
    }
}
```

### 3.2 边界情况处理

#### 3.2.1 字段映射不匹配
- **场景**：新目标表的字段与现有字段映射不匹配
- **处理**：在 `setFieldMapping()` 方法中已有处理逻辑，会自动处理不匹配的字段

#### 3.2.2 同步任务运行中
- **场景**：表映射正在同步时修改目标表名称
- **处理**：`TableGroupServiceImpl.edit()` 中已有 `assertRunning()` 检查，会阻止修改

### 3.3 数据一致性

#### 3.3.1 字段映射关系
- 修改目标表名称后，需要重新验证字段映射关系
- 如果新目标表缺少某些字段，需要在 `setFieldMapping()` 中处理

#### 3.3.2 缓存更新
- `TableGroup.initCommand()` 会重新初始化SQL命令和缓存
- 确保修改后的配置生效

## 四、改造步骤

### 4.1 后端改造

1. **修改 `TableGroupChecker.checkEditConfigModel()`**
   - 添加目标表名称参数处理
   - 调用修改后的 `checkRepeatedTable()` 方法

2. **修改 `TableGroupChecker.checkRepeatedTable()`**
   - 添加 `excludeTableGroupId` 参数
   - 更新调用处（`checkAddConfigModel()` 中调用时传 `null`）

3. **测试**
   - 单元测试：测试重命名功能
   - 集成测试：测试与现有功能的兼容性

### 4.2 前端改造

1. **修改 `editTableGroup.html`**
   - 将目标表名称改为可编辑输入框
   - 添加表单验证

2. **修改 `editTableGroup.js`**（如需要）
   - 添加目标表名称变更的提示逻辑
   - 添加表单提交前的验证

3. **测试**
   - UI测试：验证输入框显示和交互
   - 功能测试：验证重命名功能

## 五、风险评估

### 5.1 低风险
- ✅ 修改范围较小，主要涉及单个表映射的编辑功能
- ✅ 不影响添加表映射的流程
- ✅ 不影响同步任务的核心逻辑

### 5.2 中风险
- ⚠️ 需要确保字段映射关系在新目标表上仍然有效

### 5.3 注意事项
- ⚠️ 如果同步任务正在运行，修改目标表名称可能导致数据写入错误
- ⚠️ 建议在修改前检查同步任务状态（已有 `assertRunning()` 检查）

## 六、测试建议

### 6.1 功能测试
1. 正常重命名：修改目标表名称为已存在的表
2. 重命名为不存在的表：验证提示信息
3. 重命名为已存在的映射：验证冲突检查
4. 字段映射验证：验证字段映射关系是否正确更新

### 6.2 边界测试
1. 空值测试：目标表名称为空
2. 特殊字符测试：目标表名称包含特殊字符
3. 并发测试：同时修改多个表映射

### 6.3 回归测试
1. 验证添加表映射功能不受影响
2. 验证编辑字段映射功能不受影响
3. 验证同步任务功能不受影响

## 七、总结

### 7.1 改造复杂度
- **后端**：中等（需要修改2个方法，添加参数处理逻辑）
- **前端**：低（主要是UI改动）

### 7.2 改造优先级
- **优先级**：中
- **建议**：可以在下一个版本中实现

### 7.3 改造建议
1. 先实现基础功能（支持重命名）
2. 后续可以添加目标表存在性检查（可选）
3. 考虑添加重命名历史记录（可选，用于审计）

